<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entrenador de Tonalidades</title>
    <link rel="shortcut icon" href="assets/images/iconapp.png" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/cards.css">
    <style>
        body {
            touch-action: manipulation;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding-top: 20px;
        }
        .top-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
        }
        .selector-container label {
            margin-right: 5px;
            color: #ccc;
            font-size: 0.9em;
        }
        .selector-container select {
            font-size: 0.9em;
            background-color: #2c2c2c;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 4px 2px;
        }
        .circle-area {
            position: relative;
            width: 600px;
            height: 600px;
            margin: 20px auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .circle-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.7s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        .tonality {
            position: absolute;
            width: 120px;
            height: 120px;
            top: 50%;
            left: 50%;
            margin: -60px;
            background-color: #333;
            border-radius: 50%;
            border: 3px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .tonality-text {
            display: inline-block;
            color: white;
            font-size: 2.6em;
            font-weight: bold;
            transition: transform 0.7s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        .tonality.active {
            background-color: #bb86fc;
            border-color: #fff;
            transform: translate(var(--x), var(--y)) scale(1.1);
            box-shadow: 0 0 20px rgba(187, 134, 252, 0.7);
        }
        .center-display {
            position: relative;
            text-align: center;
            z-index: 10;
            width: 240px;
            height: 240px;
        }
        #scale-display-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .scale-note {
            position: absolute;
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            margin: -30px;
            background-color: #2c2c2c;
            color: #fff;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            border: 2px solid #555;
        }
        #timer-display {
            font-size: 2em;
            color: #aaa;
            margin-top: 10px;
            position: absolute;
            bottom: -80px;
            left: 50%;
            transform: translateX(-50%);
        }
        .bottom-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }
        #total-time-display {
            color: #ccc;
            font-size: 1.2em;
            margin-bottom: 15px;
            height: 1.2em;
        }
        .control-button {
            background-color: #3a3a3a;
            color: #f0f0f0;
            border: 2px solid #555;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        #startStopButton {
            background-color: #198754;
        }
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); color: white; display: none;
            justify-content: center; align-items: center; font-size: 2em; z-index: 1000;
        }
    </style>
</head>
<body>
<div id="loading-overlay">Cargando audios...</div>
<div class="wrapper">
    <header>
        <nav>
            <ul>
                <li><a href="index.html">Generador de progresiones</a></li>
                <li><a href="Index2.html">Generador de partituras</a></li>
                <li><a href="Index3.html">Generador de ondas</a></li>
                <li><a href="#" class="active-nav-link">Entrenador de Tonalidades</a></li>
                <li><a href="index5.html">Generador de cifrados</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <div class="main-container">
            <div class="top-controls">
                <div class="selector-container">
                    <label for="key-selector">Tonalidad:</label>
                    <select id="key-selector"></select>
                </div>
                <div class="selector-container">
                    <label for="mode-selector">Modo:</label>
                    <select id="mode-selector">
                        <option value="Mayor">Mayor</option>
                        <option value="Menor">Menor</option>
                        <option value="Maj7">Maj7</option>
                        <option value="m7">m7</option>
                        <option value="7">7</option>
                        <option value="Dim">Dim</option>
                        <option value="Aug">Aug</option>
                        <option value="7#11">7#11</option>
                        <option value="Sus4">Sus4</option>
                        <option value="Sus2">Sus2</option>
                        <option value="6/9">6/9</option>
                    </select>
                </div>
                <div class="selector-container">
                    <label for="time-per-key-selector">Tiempo/Tonalidad:</label>
                    <select id="time-per-key-selector">
                        <option value="-" disabled>-</option>
                        <option value="10">10s</option>
                        <option value="30" selected>30s</option>
                        <option value="60">1m</option>
                        <option value="120">2m</option>
                        <option value="180">3m</option>
                    </select>
                </div>
                 <div class="selector-container">
                    <label for="total-time-selector">Tiempo Total:</label>
                    <select id="total-time-selector">
                        <option value="-" selected>-</option>
                        <option value="600">10m</option>
                        <option value="900">15m</option>
                        <option value="1200">20m</option>
                        <option value="1800">30m</option>
                    </select>
                </div>
            </div>
            <div class="circle-area">
                <div class="circle-container" id="tonality-circle">
                    <!-- Las tonalidades se renderizan aquí con JS -->
                </div>
                <div class="center-display">
                    <div id="scale-display-container">
                        <!-- Las notas se renderizan aquí -->
                    </div>
                    <div id="timer-display">00:30</div>
                </div>
            </div>
            <div class="bottom-controls">
                <div id="total-time-display"></div>
                <button id="startStopButton" class="control-button">Iniciar</button>
            </div>
        </div>
    </main>
</div>
<footer><p> </p></footer>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const circle = document.getElementById('tonality-circle');
    const scaleDisplayContainer = document.getElementById('scale-display-container');
    const timerDisplay = document.getElementById('timer-display');
    const startStopButton = document.getElementById('startStopButton');
    const loadingOverlay = document.getElementById('loading-overlay');
    const keySelector = document.getElementById('key-selector');
    const timePerKeySelector = document.getElementById('time-per-key-selector');
    const totalTimeSelector = document.getElementById('total-time-selector');
    const totalTimeDisplay = document.getElementById('total-time-display');
    const modeSelector = document.getElementById('mode-selector');

    const tonalities = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'Db', 'Ab', 'Eb', 'Bb', 'F'];
    const escalas = {
        'Mayor': {
            'C': ['C', 'D', 'E', 'F', 'G', 'A', 'B'], 'G': ['G', 'A', 'B', 'C', 'D', 'E', 'F#'],
            'D': ['D', 'E', 'F#', 'G', 'A', 'B', 'C#'], 'A': ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#'],
            'E': ['E', 'F#', 'G#', 'A', 'B', 'C#', 'D#'], 'B': ['B', 'C#', 'D#', 'E', 'F#', 'G#', 'A#'],
            'F#': ['F#', 'G#', 'A#', 'B', 'C#', 'D#', 'E#'], 'Db': ['Db', 'Eb', 'F', 'Gb', 'Ab', 'Bb', 'C'],
            'Ab': ['Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G'], 'Eb': ['Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'D'],
            'Bb': ['Bb', 'C', 'D', 'Eb', 'F', 'G', 'A'], 'F': ['F', 'G', 'A', 'Bb', 'C', 'D', 'E']
        },
        'Menor': {
            'C': ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'Bb'], 'G': ['G', 'A', 'Bb', 'C', 'D', 'Eb', 'F'],
            'D': ['D', 'E', 'F', 'G', 'A', 'Bb', 'C'], 'A': ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
            'E': ['E', 'F#', 'G', 'A', 'B', 'C', 'D'], 'B': ['B', 'C#', 'D', 'E', 'F#', 'G', 'A'],
            'F#': ['F#', 'G#', 'A', 'B', 'C#', 'D', 'E'], 'Db': ['Db', 'Eb', 'Fb', 'Gb', 'Ab', 'Bbb', 'Cb'],
            'Ab': ['Ab', 'Bb', 'Cb', 'Db', 'Eb', 'Fb', 'Gb'], 'Eb': ['Eb', 'F', 'Gb', 'Ab', 'Bb', 'Cb', 'Db'],
            'Bb': ['Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'Ab'], 'F': ['F', 'G', 'Ab', 'Bb', 'C', 'Db', 'Eb']
        }
    };
    const chordFormulas = {
        'Mayor': { steps: [1, 3, 5], intervals: [0, 4, 7] },
        'Menor': { steps: [1, 3, 5], intervals: [0, 3, 7] },
        'Maj7': { steps: [1, 3, 5, 7], intervals: [0, 4, 7, 11] },
        'm7': { steps: [1, 3, 5, 7], intervals: [0, 3, 7, 10] },
        '7': { steps: [1, 3, 5, 7], intervals: [0, 4, 7, 10] },
        'Dim': { steps: [1, 3, 5], intervals: [0, 3, 6] },
        'Aug': { steps: [1, 3, 5], intervals: [0, 4, 8] },
        '7#11': { steps: [1, 3, 5, 7, 11], intervals: [0, 4, 7, 10, 18] },
        'Sus4': { steps: [1, 4, 5], intervals: [0, 5, 7] },
        'Sus2': { steps: [1, 2, 5], intervals: [0, 2, 7] },
        '6/9': { steps: [1, 3, 5, 6, 9], intervals: [0, 4, 7, 9, 14] }
    };
    const noteToMidiBase = { 'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11 };
    const diatonicSteps = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
    const flatToSharpMap = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };

    let audioContext;
    const audioBuffers = {};
    let currentlyPlayingNodes = [];
    const AUDIO_DURATION = 8.0;
    const QUICK_FADE_OUT = 0.1;
    const loopFadeOutTime = 4.0;
    const loopFadeInTime = 4.0;
    let previousTonality = null;

    let loopTimeoutId = null;
    let currentTonalityIndex = 0;
    let currentMode = 'Mayor';
    let duration = 30;
    let countdown;
    let totalCountdown;
    let mainTimerId = null;
    let isTimerRunning = false;
    let isAudioReady = false;

    function getCanonicalNoteName(note) {
        const octave = note.slice(-1);
        const pitch = note.slice(0, -1);
        if (flatToSharpMap[pitch]) {
            return flatToSharpMap[pitch] + octave;
        }
        return note;
    }

    function getChordNotes(rootNote, quality) {
        const formula = chordFormulas[quality];
        if (!formula) return [];

        const rootNoteLetter = rootNote.replace(/[#b]/g, '');
        const rootDiatonicIndex = diatonicSteps.indexOf(rootNoteLetter);
        const rootMidi = noteToMidiBase[rootNote] + 60;

        let lastMidiNum = -1;

        const chordNotes = formula.steps.map((step, i) => {
            const targetInterval = formula.intervals[i];
            let targetMidi = rootMidi + targetInterval;

            if (lastMidiNum !== -1 && targetMidi <= lastMidiNum) {
                targetMidi += 12;
            }
            lastMidiNum = targetMidi;

            const targetNoteLetter = diatonicSteps[(rootDiatonicIndex + step - 1) % 7];
            const naturalMidiOfTarget = noteToMidiBase[targetNoteLetter];

            let baseOctaveMidi = Math.floor(targetMidi / 12) * 12;
            let correctedNaturalMidi = baseOctaveMidi + naturalMidiOfTarget;
            
            if (Math.abs(targetMidi - correctedNaturalMidi) > 6) {
                if (targetMidi > correctedNaturalMidi) correctedNaturalMidi += 12;
                else correctedNaturalMidi -= 12;
            }

            const diff = targetMidi - correctedNaturalMidi;
            const accidental = {'-2':'bb', '-1':'b', '0':'', '1':'#', '2':'x'}[diff] || '';
            
            const finalNoteName = `${targetNoteLetter}${accidental}`;
            const octave = Math.floor(targetMidi / 12) - 1;

            return `${finalNoteName}${octave}`;
        });

        return chordNotes;
    }

    function formatNoteForFile(note) {
        const noteName = note.replace(/[0-9]/g, '');
        const octave = note.match(/[0-9]/g).join('');
        const fileNoteMap = {
            'C#': 'cs', 'Db': 'cs', 'D#': 'ds', 'Eb': 'ds', 'F#': 'fs', 'Gb': 'fs',
            'G#': 'gs', 'Ab': 'gs', 'A#': 'as', 'Bb': 'as', 'B#':'c', 'E#':'f',
            'Cb': 'b', 'Fb': 'e'
        };
        if (fileNoteMap[noteName]) return fileNoteMap[noteName] + octave;
        return noteName.toLowerCase().replace('#', 's') + octave;
    }

    async function initAudio() {
        if (audioContext) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        loadingOverlay.style.display = 'flex';
        const notesToLoad = [];
        const midiToNoteName = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        for (let midi = 48; midi <= 84; midi++) { // C3 a C6
            const noteName = midiToNoteName[midi % 12];
            const octave = Math.floor(midi / 12) - 1;
            notesToLoad.push(`${noteName}${octave}`);
        }

        const promises = notesToLoad.map(note => {
            const url = `assets/audios/${formatNoteForFile(note)}.wav`;
            console.log(`[initAudio] Intentando cargar: ${url} para nota ${note}`);
            return fetch(url)
                .then(response => {
                    console.log(`[initAudio] ${url} - response.ok: ${response.ok}, status: ${response.status}`);
                    if (!response.ok) return null;
                    return response.arrayBuffer();
                })
                .then(buffer => {
                    if (!buffer) {
                        console.warn(`[initAudio] No se obtuvo buffer para ${url}`);
                        return null;
                    }
                    return audioContext.decodeAudioData(buffer);
                })
                .then(decodedData => {
                    if (decodedData) {
                        audioBuffers[note] = decodedData;
                        console.log(`[initAudio] Audio cargado y almacenado: ${note}`);
                    } else {
                        console.warn(`[initAudio] No se pudo decodificar audio para ${url}`);
                    }
                })
                .catch(error => {
                    console.error(`[initAudio] Error al cargar ${url}:`, error);
                });
        });

        await Promise.all(promises);
        isAudioReady = true;
        loadingOverlay.style.display = 'none';
        console.log("[initAudio] Todos los audios intentados cargar. isAudioReady = true.");
    }

    function playChord(tonality, quality) {
        if (!isAudioReady || !audioContext) return;

        clearTimeout(loopTimeoutId);
        const now = audioContext.currentTime;

        const isTonalityChange = (previousTonality !== tonality && previousTonality !== null);
        const fadeOut = isTonalityChange ? QUICK_FADE_OUT : loopFadeOutTime;

        currentlyPlayingNodes.forEach(node => {
            node.gainNode.gain.linearRampToValueAtTime(0, now + fadeOut);
            node.source.stop(now + fadeOut);
        });

        const newNodes = [];
        const notes = getChordNotes(tonality, quality);
        console.log(`--- Acorde: ${tonality} ${quality} ---`);

        if (notes) {
            notes.forEach(note => {
                const canonicalNote = getCanonicalNoteName(note);
                const audioFileName = `${formatNoteForFile(canonicalNote)}.wav`;
                console.log(`Buscando: ${audioFileName} (original: ${note})`);

                const buffer = audioBuffers[canonicalNote];
                if (!buffer) {
                    console.warn(`Audio para la nota ${canonicalNote} (${audioFileName}) no encontrado.`);
                    return;
                }

                const source = audioContext.createBufferSource();
                source.buffer = buffer;

                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(1, now + loopFadeInTime);

                source.connect(gainNode).connect(audioContext.destination);
                source.start(now);
                newNodes.push({ source, gainNode });
            });
        }
        currentlyPlayingNodes = newNodes;
        previousTonality = tonality;

        const nextLoopTime = (AUDIO_DURATION - loopFadeOutTime) * 1000;
        if (nextLoopTime > 0) {
             loopTimeoutId = setTimeout(() => playChord(tonality, quality), nextLoopTime);
        }
    }

    function stopAllSounds() {
        if (!audioContext) return;
        clearTimeout(loopTimeoutId);
        const now = audioContext.currentTime;
        currentlyPlayingNodes.forEach(node => {
            node.gainNode.gain.linearRampToValueAtTime(0, now + QUICK_FADE_OUT);
            node.source.stop(now + QUICK_FADE_OUT);
        });
        currentlyPlayingNodes = [];
        previousTonality = null;
    }

    function renderOuterCircle() {
        const radius = 240;
        tonalities.forEach((tonality, i) => {
            const angle = (i / tonalities.length) * 2 * Math.PI - (Math.PI / 2);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const el = document.createElement('div');
            el.className = 'tonality';
            el.style.setProperty('--x', `${x}px`);
            el.style.setProperty('--y', `${y}px`);
            el.style.transform = `translate(var(--x), var(--y))`;

            const textSpan = document.createElement('span');
            textSpan.className = 'tonality-text';
            textSpan.textContent = tonality.replace('b', '♭').replace('#', '♯');
            el.appendChild(textSpan);
            
            circle.appendChild(el);
        });
    }

    function renderCenterDisplay(tonality, mode) {
        scaleDisplayContainer.innerHTML = '';
        let notesToDisplay;

        if (mode === 'Mayor' || mode === 'Menor') {
            notesToDisplay = escalas[mode][tonality];
        } else {
            notesToDisplay = getChordNotes(tonality, mode).map(note => note.replace(/[0-9]/g, ''));
        }

        if (!notesToDisplay) return;

        const radius = 90;
        const numNotes = notesToDisplay.length;
        notesToDisplay.forEach((note, i) => {
            const angle = (i / numNotes) * 2 * Math.PI - (Math.PI / 2);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const el = document.createElement('div');
            el.className = 'scale-note';
            el.textContent = note.replace('b', '♭').replace('#', '♯');
            el.style.transform = `translate(${x}px, ${y}px)`;
            scaleDisplayContainer.appendChild(el);
        });
    }

    function updateDisplay() {
        const rotation = -currentTonalityIndex * 30;
        circle.style.transform = `rotate(${rotation}deg)`;

        document.querySelectorAll('.tonality-text').forEach(span => {
            span.style.transform = `rotate(${-rotation}deg)`;
        });

        document.querySelectorAll('.tonality').forEach((el, index) => {
            if (index === currentTonalityIndex) {
                el.classList.add('active');
            } else {
                el.classList.remove('active');
            }
        });

        const currentTonality = tonalities[currentTonalityIndex];
        renderCenterDisplay(currentTonality, currentMode);
    }

    function switchToNextTonality() {
        currentTonalityIndex = (currentTonalityIndex + 1) % tonalities.length;
        updateDisplay();
        playChord(tonalities[currentTonalityIndex], currentMode);
    }

    function formatTime(seconds) {
        const roundedSeconds = Math.round(seconds);
        const mins = Math.floor(roundedSeconds / 60);
        const secs = roundedSeconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function updateTotalTimeDisplay(seconds) {
        totalTimeDisplay.textContent = `Tiempo total restante: ${formatTime(seconds)}`;
    }

    function updateTimers(newDuration, newTotal) {
        duration = newDuration;
        totalCountdown = newTotal;
        timerDisplay.textContent = formatTime(duration);
        updateTotalTimeDisplay(totalCountdown);

        if (isTimerRunning) {
            clearInterval(mainTimerId);
            countdown = duration;
            mainTimerId = setInterval(() => {
                countdown--;
                totalCountdown--;
                timerDisplay.textContent = formatTime(countdown);
                updateTotalTimeDisplay(totalCountdown);

                if (totalCountdown <= 0) {
                    stopTimer();
                    alert("¡Vuelta completa!");
                } else if (countdown <= 0) {
                    switchToNextTonality();
                    countdown = duration;
                }
            }, 1000);
        }
    }

    async function startTimer() {
        if (isTimerRunning) return;
        if (!isAudioReady) {
            await initAudio();
        }

        isTimerRunning = true;
        startStopButton.textContent = 'Detener';
        startStopButton.style.backgroundColor = '#dc3545';

        playChord(tonalities[currentTonalityIndex], currentMode);

        clearInterval(mainTimerId);
        countdown = duration;
        totalCountdown = duration * 12;
        timerDisplay.textContent = formatTime(countdown);
        updateTotalTimeDisplay(totalCountdown);

        mainTimerId = setInterval(() => {
            countdown--;
            totalCountdown--;
            timerDisplay.textContent = formatTime(countdown);
            updateTotalTimeDisplay(totalCountdown);

            if (totalCountdown <= 0) {
                stopTimer();
                alert("¡Vuelta completa!");
            } else if (countdown <= 0) {
                switchToNextTonality();
                countdown = duration;
            }
        }, 1000);
    }

    function stopTimer() {
        if (!isTimerRunning) return;
        isTimerRunning = false;
        clearInterval(mainTimerId);
        stopAllSounds();
        startStopButton.textContent = 'Iniciar';
        startStopButton.style.backgroundColor = '#198754';
        updateTotalTimeDisplay(duration * 12);
    }

    function populateKeySelector() {
        tonalities.forEach(tonality => {
            const option = document.createElement('option');
            option.value = tonality;
            option.textContent = tonality.replace('b', '♭').replace('#', '♯');
            keySelector.appendChild(option);
        });
    }

    // Event Listeners
    keySelector.addEventListener('change', e => {
        const selectedTonality = e.target.value;
        const newIndex = tonalities.indexOf(selectedTonality);
        if (newIndex === -1) return;

        if (isTimerRunning) {
            stopTimer();
        }

        currentTonalityIndex = newIndex;
        updateDisplay();
        timerDisplay.textContent = formatTime(duration);
        updateTotalTimeDisplay(duration * 12);
    });

    timePerKeySelector.addEventListener('change', e => {
        totalTimeSelector.value = '-';
        const newDuration = parseInt(e.target.value, 10);
        updateTimers(newDuration, newDuration * 12);
    });

    totalTimeSelector.addEventListener('change', e => {
        timePerKeySelector.value = '-';
        const totalDuration = parseInt(e.target.value, 10);
        updateTimers(totalDuration / 12, totalDuration);
    });

    modeSelector.addEventListener('change', e => {
        currentMode = e.target.value;
        updateDisplay(); // Actualizar el display central para mostrar las nuevas notas
        if (isTimerRunning) {
            stopTimer(); // Detener el temporizador y el audio
        }
    });

    startStopButton.addEventListener('click', () => {
        if (isTimerRunning) {
            stopTimer();
        } else {
            startTimer();
        }
    });

    // Inicialización
    populateKeySelector();
    renderOuterCircle();
    updateDisplay();
    updateTimers(duration, duration * 12);
});
</script>
</body>
</html>