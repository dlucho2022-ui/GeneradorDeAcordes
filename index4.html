<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entrenador de Tonalidades</title>
    <link rel="shortcut icon" href="assets/images/iconapp.png" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/cards.css">
    <style>
        body {
            touch-action: manipulation;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding-top: 20px;
        }
        .top-controls {
            display: flex;
            flex-wrap: wrap; /* Para que se ajuste en pantallas pequeñas */
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
        }
        .selector-container label {
            margin-right: 10px;
            color: #ccc;
        }
        .selector-container select {
            font-size: 1em;
            background-color: #2c2c2c;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 5px;
        }
        .circle-area {
            position: relative;
            width: 600px;
            height: 600px;
            margin: 20px auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .circle-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.7s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        .tonality {
            position: absolute;
            width: 120px;
            height: 120px;
            top: 50%;
            left: 50%;
            margin: -60px;
            background-color: #333;
            border-radius: 50%;
            border: 3px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .tonality-text {
            display: inline-block;
            color: white;
            font-size: 2.6em;
            font-weight: bold;
            transition: transform 0.7s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        .tonality.active {
            background-color: #bb86fc;
            border-color: #fff;
            transform: translate(var(--x), var(--y)) scale(1.1);
            box-shadow: 0 0 20px rgba(187, 134, 252, 0.7);
        }
        .center-display {
            position: relative;
            text-align: center;
            z-index: 10;
            width: 240px;
            height: 240px;
        }
        #scale-display-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .scale-note {
            position: absolute;
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            margin: -30px;
            background-color: #2c2c2c;
            color: #fff;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            border: 2px solid #555;
        }
        #timer-display {
            font-size: 2em;
            color: #aaa;
            margin-top: 10px;
            position: absolute;
            bottom: -80px;
            left: 50%;
            transform: translateX(-50%);
        }
        .bottom-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }
        #total-time-display {
            color: #ccc;
            font-size: 1.2em;
            margin-bottom: 15px;
            height: 1.2em; /* Para evitar que salte el layout */
        }
        .control-button {
            background-color: #3a3a3a;
            color: #f0f0f0;
            border: 2px solid #555;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        #startStopButton {
            background-color: #198754;
        }
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); color: white; display: none;
            justify-content: center; align-items: center; font-size: 2em; z-index: 1000;
        }
    </style>
</head>
<body>
<div id="loading-overlay">Cargando audios...</div>
<div class="wrapper">
    <header>
        <nav>
            <ul>
                <li><a href="index.html">Generador de progresiones</a></li>
                <li><a href="Index2.html">Generador de partituras</a></li>
                <li><a href="Index3.html">Generador de ondas</a></li>
                <li><a href="#" class="active-nav-link">Entrenador de Tonalidades</a></li>
                <li><a href="index5.html">Generador de cifrados</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <div class="main-container">
            <div class="top-controls">
                <div class="selector-container">
                    <label for="key-selector">Tonalidad Inicial:</label>
                    <select id="key-selector"></select>
                </div>
                <div class="selector-container">
                    <label for="time-per-key-selector">Tiempo por Tonalidad:</label>
                    <select id="time-per-key-selector">
                        <option value="-" disabled>-</option>
                        <option value="10">10s</option>
                        <option value="30" selected>30s</option>
                        <option value="60">1m</option>
                        <option value="120">2m</option>
                        <option value="180">3m</option>
                    </select>
                </div>
                 <div class="selector-container">
                    <label for="total-time-selector">Tiempo Total:</label>
                    <select id="total-time-selector">
                        <option value="-" selected>-</option>
                        <option value="600">10m</option>
                        <option value="900">15m</option>
                        <option value="1200">20m</option>
                        <option value="1800">30m</option>
                    </select>
                </div>
            </div>
            <div class="circle-area">
                <div class="circle-container" id="tonality-circle">
                    <!-- Las tonalidades se renderizan aquí con JS -->
                </div>
                <div class="center-display">
                    <div id="scale-display-container">
                        <!-- Las 7 notas de la escala se renderizan aquí -->
                    </div>
                    <div id="timer-display">00:30</div>
                </div>
            </div>
            <div class="bottom-controls">
                <div id="total-time-display"></div>
                <button id="startStopButton" class="control-button">Iniciar</button>
            </div>
        </div>
    </main>
</div>
<footer><p> </p></footer>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const circle = document.getElementById('tonality-circle');
    const scaleDisplayContainer = document.getElementById('scale-display-container');
    const timerDisplay = document.getElementById('timer-display');
    const startStopButton = document.getElementById('startStopButton');
    const loadingOverlay = document.getElementById('loading-overlay');
    const keySelector = document.getElementById('key-selector');
    const timePerKeySelector = document.getElementById('time-per-key-selector');
    const totalTimeSelector = document.getElementById('total-time-selector');
    const totalTimeDisplay = document.getElementById('total-time-display');

    const tonalities = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'Db', 'Ab', 'Eb', 'Bb', 'F'];
    const acordes = {
        'C': ['C4', 'E4', 'G4'], 'G': ['G4', 'B4', 'D5'], 'D': ['D4', 'F#4', 'A4'],
        'A': ['A3', 'C#4', 'E4'], 'E': ['E3', 'G#3', 'B3'], 'B': ['B3', 'D#4', 'F#4'],
        'F#': ['F#3', 'A#3', 'C#4'],'Db': ['Db4', 'F4', 'Ab4'],'Ab': ['Ab3', 'C4', 'Eb4'],
        'Eb': ['Eb3', 'G3', 'Bb3'], 'Bb': ['Bb3', 'D4', 'F4'], 'F': ['F3', 'A3', 'C4']
    };
    const escalas = {
        'C': ['C', 'D', 'E', 'F', 'G', 'A', 'B'], 'G': ['G', 'A', 'B', 'C', 'D', 'E', 'F#'],
        'D': ['D', 'E', 'F#', 'G', 'A', 'B', 'C#'], 'A': ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#'],
        'E': ['E', 'F#', 'G#', 'A', 'B', 'C#', 'D#'], 'B': ['B', 'C#', 'D#', 'E', 'F#', 'G#', 'A#'],
        'F#': ['F#', 'G#', 'A#', 'B', 'C#', 'D#', 'E#'], 'Db': ['Db', 'Eb', 'F', 'Gb', 'Ab', 'Bb', 'C'],
        'Ab': ['Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G'], 'Eb': ['Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'D'],
        'Bb': ['Bb', 'C', 'D', 'Eb', 'F', 'G', 'A'], 'F': ['F', 'G', 'A', 'Bb', 'C', 'D', 'E']
    };

    let audioContext;
    const audioBuffers = {};
    let currentlyPlayingNodes = [];
    const AUDIO_DURATION = 8.0;
    const QUICK_FADE_OUT = 0.1;
    const loopFadeOutTime = 4.0;
    const loopFadeInTime = 4.0;
    let previousTonality = null;

    let loopTimeoutId = null;
    let currentTonalityIndex = 0;
    let duration = 30;
    let countdown;
    let totalCountdown;
    let mainTimerId = null;
    let isTimerRunning = false;
    let isAudioReady = false;

    function formatNoteForFile(note) {
        const noteName = note.slice(0, -1);
        const octave = note.slice(-1);
        const fileNoteMap = {
            'C#': 'cs', 'Db': 'cs',
            'D#': 'ds', 'Eb': 'ds',
            'F#': 'fs', 'Gb': 'fs',
            'G#': 'gs', 'Ab': 'gs',
            'A#': 'as', 'Bb': 'as'
        };
        const fileNote = fileNoteMap[noteName] || noteName.toLowerCase();
        return fileNote + octave;
    }

    async function initAudio() {
        if (audioContext) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        loadingOverlay.style.display = 'flex';
        const allNotes = [...new Set(Object.values(acordes).flat())];
        const promises = allNotes.map(note => {
            const url = `assets/audios/${formatNoteForFile(note)}.wav`;
            return fetch(url)
                .then(response => response.arrayBuffer())
                .then(buffer => audioContext.decodeAudioData(buffer))
                .then(decodedData => {
                    audioBuffers[note] = decodedData;
                });
        });

        await Promise.all(promises);
        isAudioReady = true;
        loadingOverlay.style.display = 'none';
    }

    function playChord(tonality) {
        if (!isAudioReady || !audioContext) return;

        clearTimeout(loopTimeoutId);
        const now = audioContext.currentTime;

        const isTonalityChange = (previousTonality !== tonality && previousTonality !== null);
        const fadeOut = isTonalityChange ? QUICK_FADE_OUT : loopFadeOutTime;

        currentlyPlayingNodes.forEach(node => {
            node.gainNode.gain.linearRampToValueAtTime(0, now + fadeOut);
            node.source.stop(now + fadeOut);
        });

        const newNodes = [];
        const notes = acordes[tonality];
        if (notes) {
            notes.forEach(note => {
                const buffer = audioBuffers[note];
                if (!buffer) return;

                const source = audioContext.createBufferSource();
                source.buffer = buffer;

                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(1, now + loopFadeInTime);

                source.connect(gainNode).connect(audioContext.destination);
                source.start(now);
                newNodes.push({ source, gainNode });
            });
        }
        currentlyPlayingNodes = newNodes;
        previousTonality = tonality;

        const nextLoopTime = (AUDIO_DURATION - loopFadeOutTime) * 1000;
        if (nextLoopTime > 0) {
             loopTimeoutId = setTimeout(() => playChord(tonality), nextLoopTime);
        }
    }

    function stopAllSounds() {
        if (!audioContext) return;
        clearTimeout(loopTimeoutId);
        const now = audioContext.currentTime;
        currentlyPlayingNodes.forEach(node => {
            node.gainNode.gain.linearRampToValueAtTime(0, now + QUICK_FADE_OUT);
            node.source.stop(now + QUICK_FADE_OUT);
        });
        currentlyPlayingNodes = [];
        previousTonality = null;
    }

    function renderOuterCircle() {
        const radius = 240;
        tonalities.forEach((tonality, i) => {
            const angle = (i / tonalities.length) * 2 * Math.PI - (Math.PI / 2);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const el = document.createElement('div');
            el.className = 'tonality';
            el.style.setProperty('--x', `${x}px`);
            el.style.setProperty('--y', `${y}px`);
            el.style.transform = `translate(var(--x), var(--y))`;

            const textSpan = document.createElement('span');
            textSpan.className = 'tonality-text';
            textSpan.textContent = tonality.replace('b', '♭').replace('#', '♯');
            el.appendChild(textSpan);
            
            circle.appendChild(el);
        });
    }

    function renderScaleDisplay(tonality) {
        scaleDisplayContainer.innerHTML = '';
        const scaleNotes = escalas[tonality];
        if (!scaleNotes) return;

        const radius = 90;
        scaleNotes.forEach((note, i) => {
            const angle = (i / scaleNotes.length) * 2 * Math.PI - (Math.PI / 2);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const el = document.createElement('div');
            el.className = 'scale-note';
            el.textContent = note.replace('b', '♭').replace('#', '♯');
            el.style.transform = `translate(${x}px, ${y}px)`;
            scaleDisplayContainer.appendChild(el);
        });
    }

    function updateDisplay() {
        const rotation = -currentTonalityIndex * 30;
        circle.style.transform = `rotate(${rotation}deg)`;

        document.querySelectorAll('.tonality-text').forEach(span => {
            span.style.transform = `rotate(${-rotation}deg)`;
        });

        document.querySelectorAll('.tonality').forEach((el, index) => {
            if (index === currentTonalityIndex) {
                el.classList.add('active');
            } else {
                el.classList.remove('active');
            }
        });

        const currentTonality = tonalities[currentTonalityIndex];
        renderScaleDisplay(currentTonality);
    }

    function switchToNextTonality() {
        currentTonalityIndex = (currentTonalityIndex + 1) % tonalities.length;
        updateDisplay();
        playChord(tonalities[currentTonalityIndex]);
    }

    function formatTime(seconds) {
        const roundedSeconds = Math.round(seconds);
        const mins = Math.floor(roundedSeconds / 60);
        const secs = roundedSeconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function updateTotalTimeDisplay(seconds) {
        totalTimeDisplay.textContent = `Tiempo total restante: ${formatTime(seconds)}`;
    }

    function updateTimers(newDuration, newTotal) {
        duration = newDuration;
        totalCountdown = newTotal;
        timerDisplay.textContent = formatTime(duration);
        updateTotalTimeDisplay(totalCountdown);

        if (isTimerRunning) {
            clearInterval(mainTimerId);
            countdown = duration;
            mainTimerId = setInterval(() => {
                countdown--;
                totalCountdown--;
                timerDisplay.textContent = formatTime(countdown);
                updateTotalTimeDisplay(totalCountdown);

                if (totalCountdown <= 0) {
                    stopTimer();
                    alert("¡Vuelta completa!");
                } else if (countdown <= 0) {
                    switchToNextTonality();
                    countdown = duration;
                }
            }, 1000);
        }
    }

    async function startTimer() {
        if (isTimerRunning) return;
        if (!isAudioReady) {
            await initAudio();
        }

        isTimerRunning = true;
        startStopButton.textContent = 'Detener';
        startStopButton.style.backgroundColor = '#dc3545';

        playChord(tonalities[currentTonalityIndex]);

        clearInterval(mainTimerId);
        countdown = duration;
        totalCountdown = duration * 12;
        timerDisplay.textContent = formatTime(countdown);
        updateTotalTimeDisplay(totalCountdown);

        mainTimerId = setInterval(() => {
            countdown--;
            totalCountdown--;
            timerDisplay.textContent = formatTime(countdown);
            updateTotalTimeDisplay(totalCountdown);

            if (totalCountdown <= 0) {
                stopTimer();
                alert("¡Vuelta completa!");
            } else if (countdown <= 0) {
                switchToNextTonality();
                countdown = duration;
            }
        }, 1000);
    }

    function stopTimer() {
        if (!isTimerRunning) return;
        isTimerRunning = false;
        clearInterval(mainTimerId);
        stopAllSounds();
        startStopButton.textContent = 'Iniciar';
        startStopButton.style.backgroundColor = '#198754';
        updateTotalTimeDisplay(duration * 12);
    }

    function populateKeySelector() {
        tonalities.forEach(tonality => {
            const option = document.createElement('option');
            option.value = tonality;
            option.textContent = tonality.replace('b', '♭').replace('#', '♯');
            keySelector.appendChild(option);
        });
    }

    // Event Listeners
    keySelector.addEventListener('change', e => {
        const selectedTonality = e.target.value;
        const newIndex = tonalities.indexOf(selectedTonality);
        if (newIndex === -1) return;

        if (isTimerRunning) {
            stopTimer();
        }

        currentTonalityIndex = newIndex;
        updateDisplay();
        timerDisplay.textContent = formatTime(duration);
        updateTotalTimeDisplay(duration * 12);
    });

    timePerKeySelector.addEventListener('change', e => {
        totalTimeSelector.value = '-';
        const newDuration = parseInt(e.target.value, 10);
        updateTimers(newDuration, newDuration * 12);
    });

    totalTimeSelector.addEventListener('change', e => {
        timePerKeySelector.value = '-';
        const totalDuration = parseInt(e.target.value, 10);
        updateTimers(totalDuration / 12, totalDuration);
    });

    startStopButton.addEventListener('click', () => {
        if (isTimerRunning) {
            stopTimer();
        } else {
            startTimer();
        }
    });

    // Inicialización
    populateKeySelector();
    renderOuterCircle();
    updateDisplay();
    updateTimers(duration, duration * 12);
});
</script>
</body>
</html>