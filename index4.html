<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entrenador de Tonalidades</title>
    <link rel="shortcut icon" href="assets/images/iconapp.png" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/cards.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            touch-action: manipulation;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding-top: 20px;
        }
        .top-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
        }
        .direction-controls {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            margin-right: 15px; /* Add some space to the right if needed */
        }
        .selector-container {
            position: relative;
        }
        .selector-container label {
            margin-right: 5px;
            color: #ccc;
            font-size: 0.9em;
        }
        .selector-container select {
            font-size: 0.9em;
            background-color: #2c2c2c;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 4px 2px;
        }

        .circle-area {
            position: relative;
            width: 600px;
            height: 600px;
            margin: 20px auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .circle-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.7s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        .tonality {
            position: absolute;
            width: 120px;
            height: 120px;
            top: 50%;
            left: 50%;
            margin: -60px;
            background-color: #333;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer; /* Add this line */
        }
        .tonality-text {
            display: inline-block;
            color: white;
            font-size: 2.6em;
            font-weight: bold;
            transition: transform 0.7s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        .tonality.active {
            background-color: #bb86fc;
            border-color: #fff;
            transform: translate(var(--x), var(--y)) scale(1.1);
            box-shadow: 0 0 20px rgba(187, 134, 252, 0.7);
        }
        .center-display {
            position: relative;
            text-align: center;
            z-index: 10;
            width: 240px;
            height: 240px;
        }
        #scale-display-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .scale-note {
            position: absolute;
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            margin: -30px;
            background-color: #2c2c2c;
            color: #fff;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            border: 2px solid #555;
        }
        .key-signature-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5em;
            color: #bb86fc; /* A distinct color */
            font-weight: bold;
            z-index: 1; /* Ensure it's above other notes if needed */
        }
        #timer-display {
            font-size: 2em;
            color: #aaa;
            margin-top: 20px; /* Ajustado para dar espacio */
        }
        .bottom-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }
        #total-time-display {
            color: #bb86fc;
            font-size: 2em;
            margin-bottom: 15px;
            height: 1.2em;
        }
        .control-button {
            background-color: #3a3a3a;
            color: #f0f0f0;
            border: 2px solid #555;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        .arrow-button {
            background-color: #3a3a3a;
            color: #f0f0f0;
            border: 2px solid #555;
            padding: 5px 10px;
            font-size: 1.5em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            margin: 0 5px;
        }
        .arrow-button.active-direction {
            background-color: #bb86fc;
            border-color: #fff;
            box-shadow: 0 0 10px rgba(187, 134, 252, 0.7);
        }
        #startStopButton {
            background-color: #198754;
        }
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); color: white; display: none;
            justify-content: center; align-items: center; font-size: 2em; z-index: 1000;
        }
    </style>
</head>
<body>
<div id="in-page-notification" class="in-page-notification"><span id="notification-message"></span><button class="close-btn">&times;</button></div>
<div id="loading-overlay">Cargando audios...</div>
<div class="wrapper">
    <header>
        <nav>
            <ul>
                <li><a href="index.html">Generador de progresiones</a></li>
                <li><a href="Index2.html">Generador de partituras</a></li>
                <li><a href="Index3.html">Generador de ondas</a></li>
                <li><a href="#" class="active-nav-link">Círculo de quintas</a></li>
                <li><a href="index5.html">Generador de cifrados</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <div class="main-container">
            <div class="top-controls">
                <div class="direction-controls">
                    <button id="leftArrow" class="arrow-button"><</button>
                    <button id="rightArrow" class="arrow-button active-direction">></button>
                </div>
                
                <div class="selector-container">
                    <label for="mode-selector">Modo:</label>
                    <select id="mode-selector">
                        <option value="Mayor">Mayor</option>
                        <option value="Menor">Menor</option>
                        <option value="Maj7">Maj7</option>
                        <option value="m7">m7</option>
                        <option value="7">7</option>
                        <option value="Dim">Dim</option>
                        <option value="m7b5">m7b5</option>
                        <option value="dim7">dim7</option>
                        <option value="Aug">Aug</option>
                        <option value="7#11">7#11</option>
                        <option value="Sus4">Sus4</option>
                        <option value="Sus2">Sus2</option>
                        <option value="6/9">6/9</option>
                    </select>
                </div>
                <div class="selector-container">
                    <label for="time-per-key-selector">Tiempo/Tonalidad:</label>
                    <select id="time-per-key-selector">
                        <option value="-" disabled>-</option>
                        <option value="10">10s</option>
                        <option value="30">30s</option>
                        <option value="60" selected>1m</option>
                        <option value="120">2m</option>
                        <option value="180">3m</option>
                    </select>
                </div>
                 <div class="selector-container">
                    <label for="total-time-selector">Total:</label>
                    <select id="total-time-selector">
                        <option value="-" selected>-</option>
                        <option value="600">10m</option>
                        <option value="900">15m</option>
                        <option value="1200">20m</option>
                        <option value="1800">30m</option>
                    </select>
                </div>
            </div>
            <div class="circle-area">
                <div class="circle-container" id="tonality-circle">
                    <!-- Las tonalidades se renderizan aquí con JS -->
                </div>
                <div class="center-display">
                    <div id="scale-display-container">
                        <!-- Las notas se renderizan aquí -->
                    </div>
                </div>
            </div>
            <div class="bottom-controls">
                <div id="timer-display">Tonalidad: 00:30</div>
                <div id="total-time-display">Total:</div>
                <button id="startStopButton" class="control-button">Iniciar</button>
            </div>
        </div>
    </main>
</div>

    <!-- Botón Flotante de Reloj -->
    <button id="floating-clock-btn" class="floating-clock-btn" onclick="handleClockButtonClick()">
        <i class="fas fa-clock"></i>
    </button>
    <script src="assets/registro_de_tiempo.js"></script>
    <!-- Time Tracker Modal -->
    <div id="time-tracker-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-button" id="time-tracker-close-btn">&times;</span>
            <h2>Registro de Estudio</h2>
            <div class="control-group">
                <label for="time-tracker-minutes">Tiempo:</label>
                <input type="number" id="time-tracker-minutes" value="15" min="1">
                <select id="time-tracker-unit">
                    <option value="minutes">Minutos</option>
                    <option value="seconds">Segundos</option>
                </select>
            </div>
            <div id="time-tracker-display">15:00</div>
            <div class="control-group">
                <button id="time-tracker-start-btn" type="button">Iniciar</button>
                <button id="time-tracker-stop-btn" type="button" style="display: none;">Detener</button>
            </div>
        </div>
    </div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const circle = document.getElementById('tonality-circle');
    const scaleDisplayContainer = document.getElementById('scale-display-container');
    const timerDisplay = document.getElementById('timer-display');
    const startStopButton = document.getElementById('startStopButton');
    const loadingOverlay = document.getElementById('loading-overlay');
    const timePerKeySelector = document.getElementById('time-per-key-selector');
    const totalTimeSelector = document.getElementById('total-time-selector');
    const totalTimeDisplay = document.getElementById('total-time-display');
    const modeSelector = document.getElementById('mode-selector');
    let rotationDirection = 'clockwise'; // 'clockwise' or 'counter-clockwise'
    let masterGainNode;
    let currentRotationAngle = 0; // New variable

    const tonalities = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'Db', 'Ab', 'Eb', 'Bb', 'F'];
    const keySignatures = {
        'Mayor': {
            'C': '0', 'G': '1#', 'D': '2#', 'A': '3#', 'E': '4#', 'B': '5#', 'F#': '6#',
            'Db': '5b', 'Ab': '4b', 'Eb': '3b', 'Bb': '2b', 'F': '1b'
        },
        'Menor': {
            'C': '3b', 'G': '2b', 'D': '1b', 'A': '0', 'E': '1#', 'B': '2#', 'F#': '3#',
            'Db': '6b', 'Ab': '7b', 'Eb': '5b', 'Bb': '4b', 'F': '3b'
        }
    };
    const escalas = {
        'Mayor': {
            'C': ['C', 'D', 'E', 'F', 'G', 'A', 'B'], 'G': ['G', 'A', 'B', 'C', 'D', 'E', 'F#'],
            'D': ['D', 'E', 'F#', 'G', 'A', 'B', 'C#'], 'A': ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#'],
            'E': ['E', 'F#', 'G#', 'A', 'B', 'C#', 'D#'], 'B': ['B', 'C#', 'D#', 'E', 'F#', 'G#', 'A#'],
            'F#': ['F#', 'G#', 'A#', 'B', 'C#', 'D#', 'E#'], 'Db': ['Db', 'Eb', 'F', 'Gb', 'Ab', 'Bb', 'C'],
            'Ab': ['Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G'], 'Eb': ['Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'D'],
            'Bb': ['Bb', 'C', 'D', 'Eb', 'F', 'G', 'A'], 'F': ['F', 'G', 'A', 'Bb', 'C', 'D', 'E']
        },
        'Menor': {
            'C': ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'Bb'], 'G': ['G', 'A', 'Bb', 'C', 'D', 'Eb', 'F'],
            'D': ['D', 'E', 'F', 'G', 'A', 'Bb', 'C'], 'A': ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
            'E': ['E', 'F#', 'G', 'A', 'B', 'C', 'D'], 'B': ['B', 'C#', 'D', 'E', 'F#', 'G', 'A'],
            'F#': ['F#', 'G#', 'A', 'B', 'C#', 'D', 'E'], 'Db': ['Db', 'Eb', 'Fb', 'Gb', 'Ab', 'Bbb', 'Cb'],
            'Ab': ['Ab', 'Bb', 'Cb', 'Db', 'Eb', 'Fb', 'Gb'], 'Eb': ['Eb', 'F', 'Gb', 'Ab', 'Bb', 'Cb', 'Db'],
            'Bb': ['Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'Ab'], 'F': ['F', 'G', 'Ab', 'Bb', 'C', 'Db', 'Eb']
        }
    };
    const chordFormulas = {
        'Mayor': { steps: [1, 3, 5], intervals: [0, 4, 7] },
        'Menor': { steps: [1, 3, 5], intervals: [0, 3, 7] },
        'Maj7': { steps: [1, 3, 5, 7], intervals: [0, 4, 7, 11] },
        'm7': { steps: [1, 3, 5, 7], intervals: [0, 3, 7, 10] },
        '7': { steps: [1, 3, 5, 7], intervals: [0, 4, 7, 10] },
        'Dim': { steps: [1, 3, 5], intervals: [0, 3, 6] },
        'm7b5': { steps: [1, 3, 5, 7], intervals: [0, 3, 6, 10] },
        'dim7': { steps: [1, 3, 5, 7], intervals: [0, 3, 6, 9] },
        'Aug': { steps: [1, 3, 5], intervals: [0, 4, 8] },
        '7#11': { steps: [1, 3, 5, 7, 11], intervals: [0, 4, 7, 10, 18] },
        'Sus4': { steps: [1, 4, 5], intervals: [0, 5, 7] },
        'Sus2': { steps: [1, 2, 5], intervals: [0, 2, 7] },
        '6/9': { steps: [1, 3, 5, 6, 9], intervals: [0, 4, 7, 9, 14] }
    };
    const noteToMidiBase = { 'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11 };
    const diatonicSteps = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
    const flatToSharpMap = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };

    const midiToNoteName = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const enharmonicMap = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };

    let audioContext;
    const audioBuffers = {};
    let currentlyPlayingNodes = [];
    const AUDIO_DURATION = 8.0;
    const QUICK_FADE_OUT = 1.0;
    const loopFadeOutTime = 4.0;
    const loopFadeInTime = 4.0;
    let previousTonality = null;

    let loopTimeoutId = null;
    let currentTonalityIndex = 0;
    let currentMode = 'Mayor';
    let duration = parseInt(timePerKeySelector.value, 10);
    let countdown;
    let totalCountdown;
    let mainTimerId = null;
    let isTimerRunning = false;
    let isAudioReady = false;

    function getCanonicalNoteName(note) {
        const noteName = note.replace(/[0-9]/g, '');
        const octaveStr = note.match(/[0-9]/g).join('');
        let octave = parseInt(octaveStr, 10);
        let canonicalName = noteName;

        if (noteName === 'B#') {
            canonicalName = 'C';
            octave++;
        } else if (noteName === 'E#') {
            canonicalName = 'F';
        } else if (noteName === 'Cb') {
            canonicalName = 'B';
            octave--;
        } else if (noteName === 'Fb') {
            canonicalName = 'E';
        } else {
            const flatToSharp = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };
            if (flatToSharp[noteName]) {
                canonicalName = flatToSharp[noteName];
            }
        }
        return canonicalName + octave;
    }



    function getChordNotes(rootNote, quality) {
        const formula = chordFormulas[quality];
        if (!formula) return [];

        const rootNoteLetter = rootNote.replace(/[#b]/g, '');
        const rootDiatonicIndex = diatonicSteps.indexOf(rootNoteLetter);
        const rootMidi = noteToMidiBase[rootNote] + 60;

        let lastMidiNum = -1;

        const chordNotes = formula.steps.map((step, i) => {
            const targetInterval = formula.intervals[i];
            let targetMidi = rootMidi + targetInterval;

            if (lastMidiNum !== -1 && targetMidi <= lastMidiNum) {
                targetMidi += 12;
            }
            lastMidiNum = targetMidi;

            const targetNoteLetter = diatonicSteps[(rootDiatonicIndex + step - 1) % 7];
            const naturalMidiOfTarget = noteToMidiBase[targetNoteLetter];

            let baseOctaveMidi = Math.floor(targetMidi / 12) * 12;
            let correctedNaturalMidi = baseOctaveMidi + naturalMidiOfTarget;
            
            if (Math.abs(targetMidi - correctedNaturalMidi) > 6) {
                if (targetMidi > correctedNaturalMidi) correctedNaturalMidi += 12;
                else correctedNaturalMidi -= 12;
            }

            const diff = targetMidi - correctedNaturalMidi;
            const accidental = {'-2':'bb', '-1':'b', '0':'', '1':'#', '2':'x'}[diff] || '';
            
            const finalNoteName = `${targetNoteLetter}${accidental}`;
            const octave = Math.floor(targetMidi / 12) - 1;

            return `${finalNoteName}${octave}`;
        });

        // Agregar la tónica una octava más abajo
        const lowerRootMidi = rootMidi - 12;
        const lowerRootNoteName = midiToNoteName[lowerRootMidi % 12];
        const lowerRootOctave = Math.floor(lowerRootMidi / 12) - 1;
        const lowerRootFullNote = `${lowerRootNoteName}${lowerRootOctave}`;

        chordNotes.unshift(lowerRootFullNote);
        return chordNotes;
    }

    function formatNoteForFile(note) {
        const noteName = note.replace(/[0-9]/g, '');
        const octaveStr = note.match(/[0-9]/g).join('');
        
        if (noteName === 'B#') {
            return 'c' + (parseInt(octaveStr, 10) + 1);
        }
        if (noteName === 'Cb') {
            return 'b' + (parseInt(octaveStr, 10) - 1);
        }

        const fileNoteMap = {
            'C#': 'cs', 'Db': 'cs', 'D#': 'ds', 'Eb': 'ds', 'F#': 'fs', 'Gb': 'fs',
            'G#': 'gs', 'Ab': 'gs', 'A#': 'as', 'Bb': 'as', 
            'E#': 'f', 
            'Fb': 'e'
        };

        if (fileNoteMap[noteName]) {
            return fileNoteMap[noteName] + octaveStr;
        }
        
        return noteName.toLowerCase().replace('#', 's') + octaveStr;
    }

    async function initAudio() {
        if (audioContext) return;
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGainNode = audioContext.createGain();
        masterGainNode.connect(audioContext.destination);
        // Establecer el valor inicial del volumen
        masterGainNode.gain.setValueAtTime(Math.pow(10, 7 / 20), audioContext.currentTime); // Volumen fijo en +7 dB
        
        loadingOverlay.style.display = 'flex';
        const notesToLoad = [];

        for (let midi = 48; midi <= 96; midi++) { // C3 a C7
            const noteName = midiToNoteName[midi % 12];
            const octave = Math.floor(midi / 12) - 1;
            const fullNote = `${noteName}${octave}`;
            notesToLoad.push(fullNote);

            // Agregar enarmónicos si existen
            for (const flatNote in enharmonicMap) {
                if (enharmonicMap[flatNote] === noteName) {
                    notesToLoad.push(`${flatNote}${octave}`);
                }
            }
        }

        const promises = notesToLoad.map(note => {
            const url = `assets/audios/${formatNoteForFile(note)}.wav`;
            console.log(`[initAudio] Intentando cargar: ${url} para nota ${note}`);
            return fetch(url)
                .then(response => {
                    console.log(`[initAudio] ${url} - response.ok: ${response.ok}, status: ${response.status}`);
                    if (!response.ok) return null;
                    return response.arrayBuffer();
                })
                .then(buffer => {
                    if (!buffer) {
                        console.warn(`[initAudio] No se obtuvo buffer para ${url}`);
                        return null;
                    }
                    return audioContext.decodeAudioData(buffer);
                })
                .then(decodedData => {
                    if (decodedData) {
                        audioBuffers[note] = decodedData;
                        console.log(`[initAudio] Audio cargado y almacenado: ${note}`);
                    } else {
                        console.warn(`[initAudio] No se pudo decodificar audio para ${url}`);
                    }
                })
                .catch(error => {
                    console.error(`[initAudio] Error al cargar ${url}:`, error);
                });
        });

        await Promise.all(promises);
        isAudioReady = true;
        loadingOverlay.style.display = 'none';
        console.log("[initAudio] Todos los audios intentados cargar. isAudioReady = true.");
    }

    function playChord(tonality, quality) {
        if (!isAudioReady || !audioContext) return;

        clearTimeout(loopTimeoutId);
        const now = audioContext.currentTime;

        const isTonalityChange = (previousTonality !== tonality && previousTonality !== null);
        const fadeOut = isTonalityChange ? QUICK_FADE_OUT : loopFadeOutTime;

        currentlyPlayingNodes.forEach(node => {
            node.gainNode.gain.linearRampToValueAtTime(0, now + fadeOut);
            node.source.stop(now + fadeOut);
        });

        const newNodes = [];
        const notes = getChordNotes(tonality, quality);
        console.log(`--- Acorde: ${tonality} ${quality} ---`);

        if (notes) {
            notes.forEach(note => {
                const audioFileName = `${formatNoteForFile(note)}.wav`;
                console.log(`Buscando: ${audioFileName} (original: ${note})`);

                const canonicalNote = getCanonicalNoteName(note);
                const buffer = audioBuffers[canonicalNote];
                if (!buffer) {
                    console.warn(`Audio para la nota ${note} (canónica: ${canonicalNote}, archivo: ${audioFileName}) no encontrado.`);
                    return;
                }

                const source = audioContext.createBufferSource();
                source.buffer = buffer;

                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(1, now + loopFadeInTime);

                source.connect(gainNode).connect(masterGainNode);
                source.start(now);
                newNodes.push({ source, gainNode });
            });
        }
        currentlyPlayingNodes = newNodes;
        previousTonality = tonality;

        const nextLoopTime = (AUDIO_DURATION - loopFadeOutTime) * 1000;
        if (nextLoopTime > 0) {
             loopTimeoutId = setTimeout(() => playChord(tonality, quality), nextLoopTime);
        }
    }

    function stopAllSounds() {
        if (!audioContext) return;
        clearTimeout(loopTimeoutId);
        const now = audioContext.currentTime;
        currentlyPlayingNodes.forEach(node => {
            node.gainNode.gain.cancelAndHoldAtTime(now); // Cancelar automatizaciones pendientes
            node.gainNode.gain.linearRampToValueAtTime(0, now + QUICK_FADE_OUT);
            node.source.stop(now + QUICK_FADE_OUT);
        });
        currentlyPlayingNodes = [];
        previousTonality = null;
    }

    function renderOuterCircle() {
        const radius = 240;
        tonalities.forEach((tonality, i) => {
            const angle = (i / tonalities.length) * 2 * Math.PI - (Math.PI / 2);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const el = document.createElement('div');
            el.className = 'tonality';
            el.style.setProperty('--x', `${x}px`);
            el.style.setProperty('--y', `${y}px`);
            el.style.transform = `translate(var(--x), var(--y))`;

            const textSpan = document.createElement('span');
            textSpan.className = 'tonality-text';
            textSpan.textContent = tonality.replace('b', '♭').replace('#', '♯');
            el.appendChild(textSpan);

            // Add click event listener
            el.addEventListener('click', () => {
                if (isTimerRunning) {
                    stopTimer();
                }
                currentTonalityIndex = i;
                updateDisplay();
                timerDisplay.textContent = 'Tonalidad: ' + formatTime(duration);
                updateTotalTimeDisplay(duration * 12);
                modeSelector.disabled = false; // Explicitly enable the mode selector
            });
            
            circle.appendChild(el);
        });
    }

    function renderCenterDisplay(tonality, mode) {
        scaleDisplayContainer.innerHTML = '';
        let notesToDisplay;

        if (mode === 'Mayor' || mode === 'Menor') {
            notesToDisplay = escalas[mode][tonality];

            // Add key signature display
            const signature = keySignatures[mode][tonality];
            if (signature) {
                const signatureEl = document.createElement('div');
                signatureEl.className = 'key-signature-display'; // New class for styling
                signatureEl.textContent = signature.replace('#', '♯').replace('b', '♭');
                scaleDisplayContainer.appendChild(signatureEl);
            }

        } else {
            notesToDisplay = getChordNotes(tonality, mode).slice(1).map(note => note.replace(/[0-9]/g, ''));
        }

        if (!notesToDisplay) return;

        const radius = 90;
        const numNotes = notesToDisplay.length;
        notesToDisplay.forEach((note, i) => {
            const angle = (i / numNotes) * 2 * Math.PI - (Math.PI / 2);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const el = document.createElement('div');
            el.className = 'scale-note';
            el.textContent = note.replace('b', '♭').replace('#', '♯');
            el.style.transform = `translate(${x}px, ${y}px)`;
            scaleDisplayContainer.appendChild(el);
        });
    }

    function updateDisplay() {
        // Calculate the target angle for the current tonality
        const targetAngle = -currentTonalityIndex * 30;

        // Calculate the shortest path to the target angle
        let angleDifference = targetAngle - currentRotationAngle;

        // Normalize angleDifference to be between -180 and 180
        if (angleDifference > 180) angleDifference -= 360;
        if (angleDifference < -180) angleDifference += 360;

        currentRotationAngle += angleDifference; // Accumulate the rotation

        circle.style.transform = `rotate(${currentRotationAngle}deg)`;

        document.querySelectorAll('.tonality-text').forEach(span => {
            span.style.transform = `rotate(${-currentRotationAngle}deg)`;
        });

        document.querySelectorAll('.tonality').forEach((el, index) => {
            if (index === currentTonalityIndex) {
                el.classList.add('active');
            } else {
                el.classList.remove('active');
            }
        });

        const currentTonality = tonalities[currentTonalityIndex];
        renderCenterDisplay(currentTonality, currentMode);
    }

    function switchToNextTonality() {
        if (rotationDirection === 'clockwise') {
            currentTonalityIndex = (currentTonalityIndex + 1) % tonalities.length;
        } else { // counter-clockwise
            currentTonalityIndex = (currentTonalityIndex - 1 + tonalities.length) % tonalities.length;
        }
        updateDisplay();
        playChord(tonalities[currentTonalityIndex], currentMode);
    }

    function formatTime(seconds) {
        const roundedSeconds = Math.round(seconds);
        const mins = Math.floor(roundedSeconds / 60);
        const secs = roundedSeconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function updateTotalTimeDisplay(seconds) {
        totalTimeDisplay.textContent = `Total: ${formatTime(seconds)}`;
    }

    function updateTimers(newDuration, newTotal) {
        duration = newDuration;
        totalCountdown = newTotal;
        timerDisplay.textContent = 'Tonalidad: ' + formatTime(duration);
        updateTotalTimeDisplay(totalCountdown);

        if (isTimerRunning) {
            clearInterval(mainTimerId);
            countdown = duration;
            mainTimerId = setInterval(() => {
                countdown--;
                totalCountdown--;
                timerDisplay.textContent = 'Tonalidad: ' + formatTime(countdown);
                updateTotalTimeDisplay(totalCountdown);

                if (totalCountdown <= 0) {
                    stopTimer();
                    alert("¡Vuelta completa!");
                } else if (countdown <= 0) {
                    switchToNextTonality();
                    countdown = duration;
                }
            }, 1000);
        }
    }

    async function startTimer() {
        if (isTimerRunning) return;
        if (!isAudioReady) {
            await initAudio();
        }

        isTimerRunning = true;
        startStopButton.textContent = 'Detener';
        startStopButton.style.backgroundColor = '#dc3545';

        playChord(tonalities[currentTonalityIndex], currentMode);

        clearInterval(mainTimerId);
        countdown = duration;
        totalCountdown = duration * 12;
        timerDisplay.textContent = 'Tonalidad: ' + formatTime(countdown);
        updateTotalTimeDisplay(totalCountdown);

        mainTimerId = setInterval(() => {
            countdown--;
            totalCountdown--;
            timerDisplay.textContent = 'Tonalidad: ' + formatTime(countdown);
            updateTotalTimeDisplay(totalCountdown);

            if (totalCountdown <= 0) {
                stopTimer();
                alert("¡Vuelta completa!");
            } else if (countdown <= 0) {
                switchToNextTonality();
                countdown = duration;
            }
        }, 1000);
    }

    function stopTimer() {
        if (!isTimerRunning) return;
        isTimerRunning = false;
        clearInterval(mainTimerId);
        stopAllSounds();
        startStopButton.textContent = 'Iniciar';
        startStopButton.style.backgroundColor = '#198754';
        updateTotalTimeDisplay(duration * 12);
        timerDisplay.textContent = 'Tonalidad: ' + formatTime(duration);    }

    timePerKeySelector.addEventListener('change', e => {
        totalTimeSelector.value = '-';
        const newDuration = parseInt(e.target.value, 10);
        updateTimers(newDuration, newDuration * 12);
    });

    totalTimeSelector.addEventListener('change', e => {
        timePerKeySelector.value = '-';
        const totalDuration = parseInt(e.target.value, 10);
        updateTimers(totalDuration / 12, totalDuration);
    });

    modeSelector.addEventListener('change', e => {
        currentMode = e.target.value;
        updateDisplay(); // Actualizar el display central para mostrar las nuevas notas
        if (isTimerRunning) {
            stopTimer(); // Detener el temporizador y el audio
        }
    });

    startStopButton.addEventListener('click', () => {
        if (isTimerRunning) {
            stopTimer();
        } else {
            startTimer();
        }
    });

    leftArrow.addEventListener('click', () => {
        rotationDirection = 'counter-clockwise';
        leftArrow.classList.add('active-direction');
        rightArrow.classList.remove('active-direction');
    });

    rightArrow.addEventListener('click', () => {
        rotationDirection = 'clockwise';
        rightArrow.classList.add('active-direction');
        leftArrow.classList.remove('active-direction');
    });

    // Inicialización
    renderOuterCircle();
    updateDisplay();
    updateTimers(duration, duration * 12);
    });
</script>
</body>
</html>